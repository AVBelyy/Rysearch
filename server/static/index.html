<!DOCTYPE html>
<html>
<meta charset="utf-8">

<head>
	<link href="css/index.css" rel="stylesheet" type="text/css">
	<link href="css/bootstrap.css" rel="stylesheet">
	
	<!-- libraries are used in this file -->
	<script src="js/jquery-3.1.1.min.js"></script>
	<script src="js/bootstrap.js"></script>
	<script src="js/d3.min.js"></script>

	<!-- dumps (for debugging) -->
	<!-- topics_dump is here -->
	<script type="text/javascript" src="topics_dump.js"></script>
	<script type="text/javascript" src="get-documents_dump_level2_topic31.js"></script>
	<script type="text/javascript" src="recommendation_dump_228.js"></script>
</head>
<body>
	<!-- Navigation panel markup -->
		<div class="navbar navbar-inverse navbar-fixed-top">
	      <div class="navbar-inner">
	        <div class="container">
	          <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
	            <span class="icon-bar"></span>
	            <span class="icon-bar"></span>
	            <span class="icon-bar"></span>
	          </button>
	          <a class="brand" href="#">Rysearch</a>

	          <!-- Container for the list of chosen topics --> 
	          <div class="nav-collapse collapse">
	            <ul class="nav" id="chosen_topics_list">
	            </ul>
	          </div><!--/.nav-collapse -->
	        </div>
	      </div>
	    </div>

	    <div class="row-fluid" id = "main_container">
	    	<div class="span11" id="left_container">
	    		<svg id="knowledge_map_svg_container"></svg>
	    		<div class="span12" id="documents_container"></div>
	    	</div>
	    	<div class="span1" id="right_container">
	    		
	    	</div>
	    </div>
	


	<!-- The very main script -->
	<script type="text/javascript">

	/*
		Each cell center is placed in it's own vertex of grid by default. 
		Random factor (from 0 to 0.5) determines the radius of circle around the vertex where 
		the center will be placed (randomly). The less this constant - the more 
		cells look like regular rectangles.
	*/
	var random_factor = 0.3
	//	The opacity of cells in a background
	var opacity_background = 1
	//	The opacity of cells in a foreground
	var opacity_foreground = 0.85

	var IS_BACKGROUND = 0, IS_TOPICS = 1, IS_DOCS = 2,
		MODE_MAP = 0, MODE_DOCS = 1;

	//the dictionary with the information about topics
	var topics_data;
/*
	// async request for topics hierarchy
	$.ajax({url: "http://localhost:3000/get-topics", success: function(result) {
		topics_data = result;
		initialize()
	}});  
*/

	// get topics data from dump
	topics_data = topics_dump;
	var topic_keys = Object.keys(topics_data);
	
	//display_mode(MODE_DOCS);
	initialize_knowledge_map(topics_data);

	function display_mode(mode) {
		var svg = document.getElementById("knowledge_map_svg_container"),
			left_container = document.getElementById("left_container"),
			right_container = document.getElementById("right_container"),
			documents_container = d3.select(document.getElementById("documents_container"));

			d3.select(right_container).selectAll("ui").remove();
			documents_container.selectAll("h1").remove();
			documents_container.selectAll("p").remove();

		switch (mode) {
			case MODE_MAP:
				svg.setAttribute("display", "inherit");
				left_container.setAttribute("class", "span11");
				right_container.setAttribute("class", "span1");
				//alert("MODE_MAP");
				break;
			case MODE_DOCS:
				svg.setAttribute("display", "none");
				left_container.setAttribute("class", "span8");
				right_container.setAttribute("class", "span4");
				//alert("MODE_DOCS");
				break;
		}

	}

	/*
		Function that stars initialization of knowledge map and other interface elements elements.
		Designed to be the callback after topics data is aquired.
	*/
	function initialize_knowledge_map(topics_data) {

		/*
		Calculate svg canvas size
		TODO: Exclude hardcoded constant "120" = 2*svg.padding-left (placed in index.css) 
		*/
		
		//SVG canvas for knowledge map drawing

		var svg_container = document.getElementById("left_container");
		var svg_width = svg_container.offsetWidth - 120, svg_height = Number(svg_width*0.5);
		var svg = d3.select(document.getElementById("knowledge_map_svg_container"));

		svg.attr("width", svg_width).attr("height", svg_height)
			.attr("viewBox", "0 0 " + svg_width + " " + svg_height)
	
		// Dummy way to count the number of layers
		var max_level = topic_keys.reduce(function(max, key) {return topics_data[key].level_id > max ? topics_data[key].level_id : max}, 0)

		// Split topics data into the array-per-level, add the "key" field into the structure of topic data
		var levels = {}
		for (var i = 0; i < max_level; i++) {
			levels[i] = topic_keys.filter(function(key) {return topics_data[key].level_id == String(i)})
			.map(function(key) {
				var topic = topics_data[key];
				topic["key"] = key;
				topic["is_last_level"] = i == max_level ? true : false;
				return topic;
			})
		} 
		
		for (var i = 0; i < topic_keys.length; i++) {
			var key = topic_keys[i], topic = topics_data[key];
			topic["key"] = key;
			topic["is_last_level"] = topic.level_id == max_level ? true : false;
		} 

		topics_data["root"] = {
			"level_id" : "-1",
			"top_words" : "Root", 
			"children" : topic_keys.filter(function(key) {return topics_data[key].level_id == String(0)})
		}


		//draw the backgound cells without any titles on it
		drawVoronoi(svg, [], d3.range(topics_data["root"].children.length*4), opacity_background, 0)

		//draw the main cells with root-level topics
		drawVoronoi(svg, ["root"], topics_data["root"].children.map(function(key) { return topics_data[key]}),
		 opacity_foreground, 1);
	}

	//	update the list of chosen topics on the navigation bar
	//	according to the given selected_topics_list	
	function updateChosenTopicsList(selected_topics_list, topics_data, svg) {
			d3.select(document.getElementById('chosen_topics_list'))
				.selectAll("li").remove();
			d3.select(document.getElementById('chosen_topics_list'))
				.selectAll("li").data(selected_topics_list).enter().append("li")
				//.attr("class", "active")
				.append("a").attr("href", "#").text(function(d) {return topics_data[d].top_words + " > "})
				.on("click", function(key) {
					display_mode(MODE_MAP);
					new_selected_topics_list = selected_topics_list.slice(0, selected_topics_list.indexOf(key) + 1)
					var topics_list = topics_data[key].children.map(function(key){return topics_data[key]});
					drawVoronoi(svg, [], d3.range(topics_list.length*4), opacity_background, IS_BACKGROUND)
					drawVoronoi(svg, new_selected_topics_list, topics_list, opacity_foreground, IS_TOPICS)
				})
			}

	/*
		Function that draws a level of knowledge map
		type = {
			background => 0
			topics => 1
			documents => 2
		}
	*/
	function drawVoronoi(svg, selected_topics_list,
		 topics_list, opacity, type) {

		var N_cells = topics_list.length;

		var width = +svg.attr("width"), height = +svg.attr("height")

		// Calculate the number of columns and rows that's enough to contain N_points cells
		function calculateColsRowsNum(width, height, N_points) {
			var alpha = width/height;
			var num_points_h = Math.ceil(Math.sqrt(N_points/alpha)),
			num_points_w = Math.ceil(N_points/num_points_h);
			return [num_points_w, num_points_h]
		}

		//Calculate the width and height of a cell
		function getCellSize(width, height, N_points) {
			var num_points = calculateColsRowsNum(width, height, N_points),
			 	num_points_w = num_points[0], num_points_h = num_points[1];
			var cell_width = Math.floor(width/num_points_w), cell_height = Math.floor(height/num_points_h);
			return [cell_width, cell_height]
		}

		//calculate the coordinates of cell centers
		function getPoints(width, height, N_points, random_factor) {
			var num_points = calculateColsRowsNum(width, height, N_points),
			 	num_points_w = num_points[0], num_points_h = num_points[1];
			var cell_size = getCellSize(width, height, N_points),
			 	cell_width = cell_size[0], cell_height = cell_size[1];
			var coordinates_of_points = [];
			for (var i = 0, points_counter = 0, w = Math.floor(cell_width/2);
			 (i < num_points_w) & (points_counter < N_points); i++, w += cell_width) {
				for (var j = 0, h = Math.floor(cell_height/2); (j < num_points_h) & (points_counter < N_points); j++, h += cell_height) {
					coordinates_of_points.push([w + Math.random()*random_factor*cell_width,
						 													h + Math.random()*random_factor*cell_width]);
					points_counter++;
				}
			}
			return coordinates_of_points;
		}

		//coordinates of cell centers
		var points = getPoints(width, height, N_cells, random_factor)

		var voronoi = d3.voronoi().extent([[-1, -1], [width + 1, height + 1]]);

		if (type == IS_BACKGROUND) {
			var polygon = svg.append("g")
				.attr("class", "polygons")
				.selectAll("path")
				.data(d3.zip(topics_list,
				 		voronoi.polygons(points)
				 		))
				.enter().append("path")
				.call(redrawPolygon);
		}

		if (type == IS_TOPICS) {
			//generate cells 
			var polygon = svg.append("g")
				.attr("class", "polygons")
				.selectAll("path")
				.data(d3.zip(topics_list,
				 		voronoi.polygons(points)
				 		))
				.enter().append("path")
				.on("click", on_click_cell_topic)
				.call(redrawPolygon)
				;
			//generate a list of chosen topics on a navigation bar
			updateChosenTopicsList(selected_topics_list, topics_data, svg);
			
			var y_margin_between_topic_words = 20;
			for (var i = 0; i < 3; i++) {
				drawSingleTitle(svg, topics_list,
					i*y_margin_between_topic_words,
					topics_list.map(function(topic){return topic.top_words[i]}),
					on_click_cell_topic
				);
			}


			//	Function that calls when a cell or a topic is clicked
			function on_click_cell_topic() {
				var topic = this.__data__[0];
				//	Get all children of this cell
				var topics_list = topic.children.map(function(key){return topics_data[key]});

				//	Append the chosen topic to the list that will be displayed on the navigation bar
				selected_topics_list.push(topic.key)
				//	TODO: Fix this shit. Works ONLY with 3-layer models, obviously 
				if (!topic.is_last_level) {
					drawVoronoi(svg, [], d3.range(topic.children.length*4), opacity_background, IS_BACKGROUND)
					drawVoronoi(svg, selected_topics_list, topics_list, opacity_foreground, IS_TOPICS)
				} else {
					updateChosenTopicsList(selected_topics_list, topics_data, svg);
					var documents = get_documents_dump;
					drawVoronoi(svg, chosen_topics_list, documents, opacity_background, IS_DOCS);
				}

			}
			
		}

		if (type == IS_DOCS) {
			//generate cells 
			var polygon = svg.append("g")
				.attr("class", "polygons")
				.selectAll("path")
				.data(d3.zip(topics_list,
				 		voronoi.polygons(points)
				 		))
				.enter().append("path")
				.on("click", on_click_cell_doc)
				.call(redrawPolygon)
				;

			drawSingleTitle(svg, topics_list, 0,
				topics_list.map(function(doc) {return doc.doc_id}),
				on_click_cell_doc
				)

			function on_click_cell_doc() {
				doc = this.__data__[0];
				display_mode(MODE_DOCS);
				display_document(doc);
				display_recommendations(doc, recommendations_dump_228);
			}

		}

		//draw titles for polygons 
		function drawSingleTitle(svg, data, shift, titles, on_click_listener) {
			var titles = svg.append("g")
				.attr("class", "titles")
				.selectAll("text")
				//	Data for a cell title is 5-tuple:
				.data(d3.zip(
					data,											// The topic info (json element)
					points,			 										// The coordinate a cell center					 				
				 	d3.range(N_cells).map(function(x){return shift}),		// The y-shift from a cell center for this title 												
					titles													// The number of displayed word from top_words array
				))
				.enter().append("text")
				.on("click", on_click_listener)
				.call(redrawTitle)
				;
		}

		//	Function that calls right after cells creation.
		//	Do some routines to finalize the appearance of cells (colors, opacity etc.)
		function redrawPolygon(polygon) {
			polygon
				.attr("fill", function(d) {return "#" + Math.floor(0x00ff00 + Math.random()*4000).toString(16).substring(2)})
				.attr("opacity", opacity)
				.attr("d", function(d) {
					return d[1] ? "M" + d[1].join("L") + "Z" : null;
			});
		}

		//	Function that calls right after cells creation.
		//	Do some routines to finalize the appearance of titles (coordinates, text etc.)
		function redrawTitle(title) {
			var cell_size = getCellSize(width, height, N_cells),
				cell_width = cell_size[0], cell_height = cell_size[1];
			title.text(function(d) {
				return d[3]
			})
			.attr("x", function(d) {
				var x = Math.floor(d[1][0]) - Math.floor((1-2*random_factor)*cell_width*0.5);
				return x;})
			.attr("y", function(d) {
				var y = Math.floor(d[1][1]) - Math.floor((1-2*random_factor)*cell_height*0.5) + d[2];
				return y;})
		}
	}

	function display_recommendations(doc, recommendations_data) {
		var right_container = d3.select(document.getElementById("right_container"));
		
		var recommendation_blocks = right_container.append("ui").attr("class", "thumbnails")
			.selectAll("li").data(recommendations_data).enter()
			.append("li").attr("class", "span10")
			.append("a").attr("class", "thumbnail")
		
		recommendation_blocks.on("click", function(doc) {
			display_mode(MODE_DOCS);
			display_document(doc);
			display_recommendations(doc, recommendations_data);
		})
		recommendation_blocks.append("h6").text(function(doc){return doc.title});
		recommendation_blocks.append("p").text(function(doc){return doc.markdown.split(".")
			.slice(0, 1).join(".")});
	}

	function display_document(doc) {
		var documents_container = d3.select(document.getElementById("documents_container"));
		documents_container.append("h1").attr("align", "center").text(doc.title);
		documents_container.append("p").text(doc.markdown);
	}

	</script>
</body>
</html>
