<!DOCTYPE html>
<html>
<meta charset="utf-8">

<head>
	<link href="css/index.css" rel="stylesheet" type="text/css">
	<link href="css/bootstrap.css" rel="stylesheet">
	
	<!-- libraries are used in this file -->
	<script src="js/jquery-3.1.1.min.js"></script>
	<script src="js/bootstrap.js"></script>
	<script src="js/d3.min.js"></script>

	<!-- dumps (for debugging) -->
	<!-- topics_dump is here -->
	<script src="topics_dump.js"></script>
</head>
<body>
	<!-- Navigation panel markup -->
	<div class="navbar navbar-inverse navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="brand" href="#">Rysearch</a>

          <!-- Container for the list of chosen topics --> 
          <div class="nav-collapse collapse">
            <ul class="nav" id="chosen_topics_list">
            </ul>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="row-fluid">
    	<div class="span8">
    		<svg viewBox="0 0 700 600" width="700" height="600" id="knowledge_map_svg_container"></svg>
    	</div>
    	<div class="span4">
    		<H1>This is right span</H1>
    	</div>
    </div>
	


	<!-- The very main script -->
	<script type="text/javascript">



	//SVG canvas for knowledge map drawing
	var svg = d3.select(document.getElementById("knowledge_map_svg_container"));	
	/*
		Each cell center is placed in it's own vertex of grid by default. 
		Random factor (from 0 to 0.5) determines the radius of circle around the vertex where 
		the center will be placed (randomly). The less this constant - the more 
		cells look like regular rectangles.
	*/
	var random_factor = 0.3
	//	The opacity of cells in a background
	var opacity_background = 0.85
	//	The opacity of cells in a foreground
	var opacity_foreground = 0.85

	//the dictionary with the information about topics
	var topics_data;
/*
	// async request for topics hierarchy
	$.ajax({url: "http://localhost:3000/get-topics", success: function(result) {
		topics_data = result;
		initialize()
	}});  
*/

	// get topics data from dump
	topics_data = topics_dump;
	var topic_keys = Object.keys(topics_data);

	initialize_knowledge_map(svg, topics_data);
	

	/*
		Function that stars initialization of knowledge map and other interface elements elements.
		Designed to be the callback after topics data is aquired.
	*/
	function initialize_knowledge_map(svg, topics_data) {
	
		// Dummy way to count the number of layers
		var levels_indexes = new Set()
		topic_keys.map(function(key) {levels_indexes.add(topics_data[key].level_id); return key});

		// Split topics data into the array-per-level, add the "key" field into the structure of topic data
		var levels = {}
		for (var i = 0; i < levels_indexes.size; i++) {
			levels[i] = topic_keys.filter(function(key) {return topics_data[key].level_id == String(i)})
			.map(function(key) {
				var topic = topics_data[key];
				topic["key"] = key;
				return topic;
			})
		}

		//get the number of cells into the top level
		var N_cells = levels[0].length

		//draw the backgound cells without any titles on it
		drawVoronoi(svg, N_cells*4, [], d3.range(N_cells*4), opacity_background, true)

		//draw the main cells with root-level topics
		drawVoronoi(svg, N_cells, [], levels[0], opacity_foreground, false);
	}

	/*
		Function that draws a level of knowledge map
	*/
	function drawVoronoi(svg, N_cells, selected_topics_list,
		 topic_list, opacity, isBackground) {

		var width = +svg.attr("width"), height = +svg.attr("height")

		// Calculate the number of columns and rows that's enough to contain N_points cells
		function calculateColsRowsNum(width, height, N_points) {
			var alpha = width/height;
			var num_points_h = Math.ceil(Math.sqrt(N_points/alpha)),
			num_points_w = Math.ceil(N_points/num_points_h);
			return [num_points_w, num_points_h]
		}

		//Calculate the width and height of a cell
		function getCellSize(width, height, N_points) {
			var num_points = calculateColsRowsNum(width, height, N_points),
			 	num_points_w = num_points[0], num_points_h = num_points[1];
			var cell_width = Math.floor(width/num_points_w), cell_height = Math.floor(height/num_points_h);
			return [cell_width, cell_height]
		}

		//calculate the coordinates of cell centers
		function getPoints(width, height, N_points, random_factor) {
			var num_points = calculateColsRowsNum(width, height, N_points),
			 	num_points_w = num_points[0], num_points_h = num_points[1];
			var cell_size = getCellSize(width, height, N_points),
			 	cell_width = cell_size[0], cell_height = cell_size[1];
			var coordinates_of_points = [];
			for (var i = 0, points_counter = 0, w = Math.floor(cell_width/2);
			 (i < num_points_w) & (points_counter < N_points); i++, w += cell_width) {
				for (var j = 0, h = Math.floor(cell_height/2); (j < num_points_h) & (points_counter < N_points); j++, h += cell_height) {
					coordinates_of_points.push([w + Math.random()*random_factor*cell_width,
						 													h + Math.random()*random_factor*cell_width]);
					points_counter++;
				}
			}
			return coordinates_of_points;
		}

		//coordinates of cell centers
		var points = getPoints(width, height, N_cells, random_factor)

		var voronoi = d3.voronoi().extent([[-1, -1], [width + 1, height + 1]]);

		//generate cells 
		var polygon = svg.append("g")
			.attr("class", "polygons")
			.selectAll("path")
			.data(d3.zip(d3.range(N_cells),
			 		voronoi.polygons(points),
			 		topic_list))
			.enter().append("path")
			.on("click", on_click_cell)
			.call(redrawPolygon)
			;

		//	update the list of chosen topics on the navigation bar
		//	according to the given selected_topics_list
		function updateChosenTopicsList(selected_topics_list) {
			d3.select(document.getElementById('chosen_topics_list'))
				.selectAll("li")
				.data(selected_topics_list).enter().append("li")
				.attr("class", "active")
				.append("a").attr("href", "#").text(function(d){return topics_data[d].top_words + " > "});
			}

		if(!isBackground) {
			//generate a list of chosen topics on a navigation bar
			updateChosenTopicsList(selected_topics_list);
			
			var y_margin_between_topic_words = 20;
			for (var i = 0; i < 3; i++) {
				drawSingleTitle(svg, i, i*y_margin_between_topic_words);
			}

			//draw titles for polygons 
			function drawSingleTitle(svg, word_number, shift) {
				var titles = svg.append("g")
					.attr("class", "titles")
					.selectAll("text")
					//	Data for a cell title is 5-tuple:
					.data(d3.zip(d3.range(N_cells),								// The number of a cell
						points,			 										// The coordinate a cell center
					 	topic_list,												// The topic info (json element)
					 	d3.range(N_cells).map(function(x){return shift}),		// The y-shift from a cell center for this title 
 																		
						d3.range(N_cells).map(function(x){return word_number})	// The number of displayed word from top_words array
					))
					.enter().append("text")
					.on("click", on_click_cell)
					.call(redrawTitle)
					;
			}
		}

		//	Function that calls when a cell is clicked
		function on_click_cell() {
			var topic_num = this.__data__[0];
			var topic = this.__data__[2];
			var topic_list = []
			//	Get all children of this cell
			for (var i = 0; i < topic.children.length; i++) {
				topic_list.push(topics_data[topic.children[i]])
			}

			//	Append the chosen topic to the list that will be displayed on the navigation bar
			selected_topics_list.push(topic.key)
			//	TODO: Fix this shit. Works ONLY with 3-layer models, obviously 
			if (topic.level_id < 2) {
				drawVoronoi(svg, topic.children.length*4, [],
					d3.range(topic.children.length*4), 1, true)
				drawVoronoi(svg, topic.children.length, 
					 selected_topics_list, topic_list, opacity_background, false)
			} else {
				updateChosenTopicsList(selected_topics_list);
				//	Hide svg element
				svg.attr("display", "none");
				//	Call to draw the topic 
				drawDocumentContent(selected_topics_list, topic);
			}

		}


		//	This part has to be overwritten
		function drawDocumentContent(selected_topics_list, topic) {
			function onClickPrevButton() {
				selected_topics_list.pop()
				var topic_key = selected_topics_list.pop()
				var topic = topics_data[topic_key]
				//alert(topic_key)
				var topic_list = []
				for (var i = 0; i < topic.children.length; i++) {
					topic_list.push(topics_data[topic.children[i]])
				}
				selected_topics_list.push(topic.key)
				var svg = d3.select(svg).attr("display", 1)
				drawVoronoi(svg, topic.children.length*4, width, height, [],
					d3.range(topic.children.length*4), 1, true)
				drawVoronoi(svg, topic.children.length, width, height,
					 selected_topics_list, topic_list, opacity_background, false)
			}

			d3.select("body").append("H1").text(topic.top_words.toString())
			d3.select('body').append("p").text(d3.range(40).map(function(x){
				return topic.top_words.toString() + "\n"
			}))
			document.getElementById('home_button').onclick = function(x) {
				svg.attr("display", "inherit")
				drawVoronoi(svg, levels[0].length*4, width, height, [], d3.range(N_cells*4), 1, true)
				drawVoronoi(svg, levels[0].length, width, height, [], levels[0], opacity_background, false);
			}

		}


		//	Function that calls right after cells creation.
		//	Do some routines to finalize the appearance of cells (colors, opacity etc.)
		function redrawPolygon(polygon) {
			polygon
				.attr("fill", function(d) {return "#" + Math.floor(0x00ff00 + Math.random()*4000).toString(16).substring(2)})
				.attr("opacity", opacity)
				.attr("d", function(d) {
					return d[1] ? "M" + d[1].join("L") + "Z" : null;
			});
		}

		//	Function that calls right after cells creation.
		//	Do some routines to finalize the appearance of titles (coordinates, text etc.)
		function redrawTitle(title) {
			var cell_size = getCellSize(width, height, N_cells),
				cell_width = cell_size[0], cell_height = cell_size[1];
			title.text(function(d) {
				return d[2].top_words[d[4]]
			})
			.attr("x", function(d) {
				var x = Math.floor(d[1][0]) - Math.floor((1-2*random_factor)*cell_width*0.5);
				return x;})
			.attr("y", function(d) {
				var y = Math.floor(d[1][1]) - Math.floor((1-2*random_factor)*cell_height*0.5) + d[3];
				return y;})
		}
	}

	</script>
</body>
</html>
